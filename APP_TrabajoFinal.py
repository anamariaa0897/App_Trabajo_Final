# -*- coding: utf-8 -*-
"""Despliegue_Trabajo_final_streamlit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MvtG7_unNWXu7o-YcTCl9Dg_2435ZpMk

# Despliegue

- Cargamos el modelo
- Cargamos los datos futuros
- Preparar los datos futuros
- Aplicamos el modelo para la predicción
"""

# app.py
import streamlit as st
import datetime
import pickle
import pandas as pd

st.set_page_config(page_title="Predicción de SKU", layout="centered")

st.title('Predicción de SKU')

# ----------------------
# Cargar el pickle con resultados/modelos
# ----------------------
PICKLE_PATH = "modelo-reg-resultados.pkl"   # ajusta si tu archivo tiene otro nombre

@st.cache_data(show_spinner=False)
def cargar_payload(path=PICKLE_PATH):
    with open(path, "rb") as f:
        payload = pickle.load(f)
    return payload

try:
    payload = cargar_payload()
except FileNotFoundError:
    st.error(f"No se encontró el archivo {PICKLE_PATH}. Coloca el pkl en el mismo directorio o ajusta PICKLE_PATH.")
    st.stop()

# ----------------------
# Extraer SKUs disponibles (intenta desde los resultados guardados)
# ----------------------
def extraer_skus(payload):
    skus = set()
    # payload esperado: {"resultados": { "media_movil_por_sku": {"output": ...}, ...}, "meta": {...}}
    resultados = payload.get("resultados", {}) if isinstance(payload, dict) else {}

    for name, info in resultados.items():
        out = info.get("output") if isinstance(info, dict) else info
        # caso: output es DataFrame
        if isinstance(out, pd.DataFrame):
            for col in ["Sku", "sku", "SKU"]:
                if col in out.columns:
                    skus.update(out[col].astype(str).unique().tolist())
        # caso: output es tupla (df_resultados, df_metricas)
        if isinstance(out, (list, tuple)) and len(out) >= 1 and isinstance(out[0], pd.DataFrame):
            df0 = out[0]
            for col in ["Sku", "sku", "SKU"]:
                if col in df0.columns:
                    skus.update(df0[col].astype(str).unique().tolist())

    # fallback: si no encontramos SKUs en payload, usar lista estática (puedes pegar la tuya)
    if not skus:
        # lista corta de ejemplo; reemplaza con tu lista completa si lo prefieres
        skus = {
            "01BL012K20","01BL012KC22H","01BL012KF23H"
        }
    return sorted(list(skus))

sku_options = extraer_skus(payload)

# ----------------------
# Controles de entrada
# ----------------------
min_date = datetime.date(2022, 1, 2)
max_date = datetime.date(2025, 8, 24)
default = min_date

semana = st.slider(
    'Selecciona una semana (cada 7 días)',
    min_value=min_date,
    max_value=max_date,
    value=default,
    step=datetime.timedelta(weeks=1)
)

st.write("Fecha (inicio de la semana) seleccionada:", semana)

Sku = st.selectbox('Sku', sku_options)

# ----------------------
# Lógica para obtener la predicción desde el payload
# ----------------------
def buscar_prediccion_en_df(df, sku, fecha_seleccionada):
    """
    Intenta encontrar la fila en df que corresponda al sku y a la semana seleccionada.
    Compara en forma robusta transformando la columna 'semana' a datetime.
    """
    if df is None or df.empty:
        return None

    # Normaliza nombres de columna posibles
    col_sem = None
    for c in ["semana", "Semana", "fecha", "date"]:
        if c in df.columns:
            col_sem = c
            break
    col_sku = None
    for c in ["Sku", "sku", "SKU"]:
        if c in df.columns:
            col_sku = c
            break
    if col_sku is None:
        return None

    # Filtrar por sku primero
    df_f = df[df[col_sku].astype(str) == str(sku)].copy()
    if df_f.empty:
        return None

    # Si no hay columna fecha, devolver última predicción disponible para el sku
    if col_sem is None:
        return df_f

    # intentar convertir columna semana a datetime
    try:
        df_f[col_sem + "_dt"] = pd.to_datetime(df_f[col_sem])
    except Exception:
        # si ya está en objeto fecha, sigue
        try:
            df_f[col_sem + "_dt"] = df_f[col_sem]
        except Exception:
            return None

    # comparar por fecha exacta (fecha seleccionada es datetime.date -> convertir a timestamp)
    target = pd.to_datetime(fecha_seleccionada)
    match = df_f[df_f[col_sem + "_dt"] == target]
    if not match.empty:
        return match
    # si no hay match exacto, devolver la fila más cercana posterior o anterior
    df_f = df_f.sort_values(col_sem + "_dt")
    # buscar el índice donde target encajaría
    dif = (df_f[col_sem + "_dt"] - target).abs()
    nearest = df_f.loc[dif.idxmin()]
    return pd.DataFrame([nearest])

# Buscar en payload
prediction_df = None
resultados = payload.get("resultados", {}) if isinstance(payload, dict) else {}

# revisar cada método guardado por si alguno tiene un DataFrame con predicciones
for name, info in resultados.items():
    out = info.get("output") if isinstance(info, dict) else info
    # si out es tuple y primer elemento df
    candidate_df = None
    if isinstance(out, pd.DataFrame):
        candidate_df = out
    elif isinstance(out, (list, tuple)) and len(out) >= 1 and isinstance(out[0], pd.DataFrame):
        candidate_df = out[0]

    if candidate_df is not None:
        found = buscar_prediccion_en_df(candidate_df, Sku, semana)
        if found is not None and not found.empty:
            prediction_df = (name, found)   # guardamos nombre del método y df encontrado
            break

# ----------------------
# Mostrar resultado o instrucciones si no hay
# ----------------------
if prediction_df is not None:
    metodo, df_found = prediction_df
    st.success(f"Predicción encontrada en: {metodo}")
    st.dataframe(df_found)
    # intentar mostrar columnas típicas de predicción
    for col in ["prediccion_ma","prediccion","prediccion_ma_val","pred"]:
        if col in df_found.columns:
            st.write("Predicción (ej.):", df_found[col].values)
            break
else:
    st.warning("No se encontró una predicción directa para ese SKU y semana en los DataFrames guardados del pkl.")
    st.write("Posibles razones y soluciones:")
    st.write("- Guardaste **modelos** (objetos con `.predict`) en el pkl en lugar de resultados. En ese caso, necesitas adaptar el código para llamar a `modelo.predict()` pasándole los datos apropiados (df_entrenamiento y df_test o la fila con features).")
    st.write("- O bien el formato de las fechas en tu DataFrame no coincide exactamente con `datetime.date`. Revisa la columna `semana` en tus DataFrames guardados.")
    st.write("Si quieres, pega aquí el contenido de `payload['resultados'].keys()` y `type(payload['resultados']['media_movil_por_sku']['output'])` y te doy el snippet exacto para llamar a tu modelo.")

# ----------------------
# Nota de uso
# ----------------------
st.markdown("---")
st.write("Instrucciones rápidas:")
st.write("1. Ejecuta `streamlit run app.py` en la terminal para abrir la app.")
st.write("2. Si en el pkl guardaste **modelos** (objetos con método `.predict`), debes adaptar la sección de búsqueda para instanciar/llamar al modelo con los inputs adecuados. Si guardaste resultados (DataFrames), la app los mostrará directamente.")